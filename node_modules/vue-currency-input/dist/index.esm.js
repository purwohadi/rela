/**
 * Vue Currency Input 2.3.0
 * (c) 2018-2021 Matthias Stiller
 * @license MIT
 */
import { ref, getCurrentInstance, isVue3, computed, watch, onUnmounted } from 'vue-demi';

const escapeRegExp = (str) => {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};
const removeLeadingZeros = (str) => {
    return str.replace(/^0+(0$|[^0])/, '$1');
};
const count = (str, search) => {
    return (str.match(new RegExp(escapeRegExp(search), 'g')) || []).length;
};
const substringBefore = (str, search) => {
    return str.substring(0, str.indexOf(search));
};

var CurrencyDisplay;
(function (CurrencyDisplay) {
    CurrencyDisplay["symbol"] = "symbol";
    CurrencyDisplay["narrowSymbol"] = "narrowSymbol";
    CurrencyDisplay["code"] = "code";
    CurrencyDisplay["name"] = "name";
    CurrencyDisplay["hidden"] = "hidden";
})(CurrencyDisplay || (CurrencyDisplay = {}));
var ValueScaling;
(function (ValueScaling) {
    ValueScaling["precision"] = "precision";
    ValueScaling["thousands"] = "thousands";
    ValueScaling["millions"] = "millions";
    ValueScaling["billions"] = "billions";
})(ValueScaling || (ValueScaling = {}));

const DECIMAL_SEPARATORS = [',', '.', 'Ù«'];
const INTEGER_PATTERN = '(0|[1-9]\\d*)';
class CurrencyFormat {
    constructor(options) {
        var _a, _b, _c, _d;
        const { currency, currencyDisplay, locale, precision } = options;
        this.currencyDisplay = currencyDisplay !== CurrencyDisplay.hidden ? currencyDisplay : undefined;
        const numberFormat = new Intl.NumberFormat(locale, { currency, currencyDisplay: this.currencyDisplay, style: 'currency' });
        const formatSample = numberFormat.format(1);
        const formatParts = numberFormat.formatToParts(123456);
        this.locale = locale;
        this.currency = currency;
        this.digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((i) => i.toLocaleString(locale));
        this.decimalSymbol = (_a = formatParts.find(({ type }) => type === 'decimal')) === null || _a === void 0 ? void 0 : _a.value;
        this.groupingSymbol = (_b = formatParts.find(({ type }) => type === 'group')) === null || _b === void 0 ? void 0 : _b.value;
        this.minusSymbol = substringBefore(Number(-1).toLocaleString(locale), this.digits[1]);
        if (this.decimalSymbol === undefined) {
            this.minimumFractionDigits = this.maximumFractionDigits = 0;
        }
        else if (typeof precision === 'number') {
            this.minimumFractionDigits = this.maximumFractionDigits = precision;
        }
        else {
            this.minimumFractionDigits = (_c = precision === null || precision === void 0 ? void 0 : precision.min) !== null && _c !== void 0 ? _c : numberFormat.resolvedOptions().minimumFractionDigits;
            this.maximumFractionDigits = (_d = precision === null || precision === void 0 ? void 0 : precision.max) !== null && _d !== void 0 ? _d : numberFormat.resolvedOptions().maximumFractionDigits;
        }
        this.prefix = substringBefore(formatSample, this.digits[1]);
        this.negativePrefix = substringBefore(numberFormat.format(-1), this.digits[1]);
        this.suffix = formatSample.substring(formatSample.lastIndexOf(this.decimalSymbol ? this.digits[0] : this.digits[1]) + 1);
    }
    parse(str) {
        if (str) {
            const negative = this.isNegative(str);
            str = this.normalizeDigits(str);
            str = this.stripCurrencySymbol(str, negative);
            str = this.stripMinusSymbol(str);
            const fraction = this.decimalSymbol ? `(?:${escapeRegExp(this.decimalSymbol)}(\\d*))?` : '';
            const match = this.stripGroupingSeparator(str).match(new RegExp(`^${INTEGER_PATTERN}${fraction}$`));
            if (match && this.isValidIntegerFormat(this.decimalSymbol ? str.split(this.decimalSymbol)[0] : str, Number(match[1]))) {
                return Number(`${negative ? '-' : ''}${this.onlyDigits(match[1])}.${this.onlyDigits(match[2] || '')}`);
            }
        }
        return null;
    }
    isValidIntegerFormat(formattedNumber, integerNumber) {
        const options = { style: 'currency', currency: this.currency, currencyDisplay: this.currencyDisplay, minimumFractionDigits: 0 };
        return [
            this.stripCurrencySymbol(this.normalizeDigits(integerNumber.toLocaleString(this.locale, {
                ...options,
                useGrouping: true
            })), false),
            this.stripCurrencySymbol(this.normalizeDigits(integerNumber.toLocaleString(this.locale, {
                ...options,
                useGrouping: false
            })), false)
        ].includes(formattedNumber);
    }
    format(value, options = {
        minimumFractionDigits: this.minimumFractionDigits,
        maximumFractionDigits: this.maximumFractionDigits
    }) {
        return value != null
            ? value.toLocaleString(this.locale, {
                style: 'currency',
                currency: this.currency,
                currencyDisplay: this.currencyDisplay,
                ...options
            })
            : '';
    }
    toFraction(str) {
        return `${this.digits[0]}${this.decimalSymbol}${this.onlyLocaleDigits(str.substr(1)).substr(0, this.maximumFractionDigits)}`;
    }
    isFractionIncomplete(str) {
        return !!this.normalizeDigits(this.stripGroupingSeparator(str)).match(new RegExp(`^${INTEGER_PATTERN}${escapeRegExp(this.decimalSymbol)}$`));
    }
    isNegative(str) {
        return str.startsWith(this.negativePrefix) || str.replace('-', this.minusSymbol).startsWith(this.minusSymbol);
    }
    insertCurrencySymbol(str, negative) {
        return `${negative ? this.negativePrefix : this.prefix}${str}${this.suffix}`;
    }
    stripGroupingSeparator(str) {
        return this.groupingSymbol !== undefined ? str.replace(new RegExp(escapeRegExp(this.groupingSymbol), 'g'), '') : str;
    }
    stripMinusSymbol(str) {
        return str.replace('-', this.minusSymbol).replace(this.minusSymbol, '');
    }
    stripCurrencySymbol(str, negative) {
        return str.replace(negative ? this.negativePrefix : this.prefix, '').replace(this.suffix, '');
    }
    normalizeDecimalSeparator(str, from) {
        DECIMAL_SEPARATORS.forEach((s) => {
            str = str.substr(0, from) + str.substr(from).replace(s, this.decimalSymbol);
        });
        return str;
    }
    normalizeDigits(str) {
        if (this.digits[0] !== '0') {
            this.digits.forEach((digit, index) => {
                str = str.replace(new RegExp(digit, 'g'), String(index));
            });
        }
        return str;
    }
    onlyDigits(str) {
        return this.normalizeDigits(str).replace(/\D+/g, '');
    }
    onlyLocaleDigits(str) {
        return str.replace(new RegExp(`[^${this.digits.join('')}]*`, 'g'), '');
    }
}

class AbstractInputMask {
    constructor(currencyFormat) {
        this.currencyFormat = currencyFormat;
    }
}
class DefaultInputMask extends AbstractInputMask {
    conformToMask(str, previousConformedValue = '') {
        const negative = this.currencyFormat.isNegative(str);
        const checkIncompleteValue = (str) => {
            if (str === '' && negative && previousConformedValue !== this.currencyFormat.negativePrefix) {
                return '';
            }
            else if (this.currencyFormat.maximumFractionDigits > 0) {
                if (this.currencyFormat.isFractionIncomplete(str)) {
                    return str;
                }
                else if (str.startsWith(this.currencyFormat.decimalSymbol)) {
                    return this.currencyFormat.toFraction(str);
                }
            }
            return null;
        };
        let value = str;
        value = this.currencyFormat.stripCurrencySymbol(value, negative);
        value = this.currencyFormat.stripMinusSymbol(value);
        const incompleteValue = checkIncompleteValue(value);
        if (incompleteValue != null) {
            return this.currencyFormat.insertCurrencySymbol(incompleteValue, negative);
        }
        const [integer, ...fraction] = value.split(this.currencyFormat.decimalSymbol);
        const integerDigits = removeLeadingZeros(this.currencyFormat.onlyDigits(integer));
        const fractionDigits = this.currencyFormat.onlyDigits(fraction.join('')).substr(0, this.currencyFormat.maximumFractionDigits);
        const invalidFraction = fraction.length > 0 && fractionDigits.length === 0;
        const invalidNegativeValue = integerDigits === '' && negative && (previousConformedValue === str.slice(0, -1) || previousConformedValue !== this.currencyFormat.negativePrefix);
        if (invalidFraction || invalidNegativeValue) {
            return previousConformedValue;
        }
        else if (integerDigits.match(/\d+/)) {
            return {
                numberValue: Number(`${negative ? '-' : ''}${integerDigits}.${fractionDigits}`),
                fractionDigits
            };
        }
        else {
            return '';
        }
    }
}
class AutoDecimalDigitsInputMask extends AbstractInputMask {
    conformToMask(str, previousConformedValue = '') {
        if (str === '' ||
            (this.currencyFormat.parse(previousConformedValue) === 0 &&
                this.currencyFormat.stripCurrencySymbol(previousConformedValue, true).slice(0, -1) === this.currencyFormat.stripCurrencySymbol(str, true))) {
            return '';
        }
        const negative = this.currencyFormat.isNegative(str);
        const numberValue = this.currencyFormat.stripMinusSymbol(str) === ''
            ? -0
            : Number(`${negative ? '-' : ''}${removeLeadingZeros(this.currencyFormat.onlyDigits(str))}`) / Math.pow(10, this.currencyFormat.maximumFractionDigits);
        return {
            numberValue,
            fractionDigits: numberValue.toFixed(this.currencyFormat.maximumFractionDigits).slice(-this.currencyFormat.maximumFractionDigits)
        };
    }
}

const DEFAULT_OPTIONS = {
    locale: undefined,
    currency: undefined,
    currencyDisplay: undefined,
    exportValueAsInteger: false,
    hideGroupingSeparatorOnFocus: true,
    hideCurrencySymbolOnFocus: true,
    hideNegligibleDecimalDigitsOnFocus: true,
    precision: undefined,
    autoDecimalDigits: false,
    valueRange: undefined,
    autoSign: true,
    useGrouping: true,
    valueScaling: undefined
};
class CurrencyInput {
    constructor(el, options) {
        this.el = el;
        this.numberValue = null;
        this.addEventListener();
        this.init(options);
        this.setValue(this.currencyFormat.parse(this.el.value));
    }
    setOptions(options) {
        this.init(options);
        this.applyFixedFractionFormat(this.numberValue, true);
    }
    getValue() {
        const numberValue = this.valueScaling && this.numberValue != null ? this.toInteger(this.numberValue, this.valueScaling) : this.numberValue;
        return { number: numberValue, formatted: this.formattedValue };
    }
    setValue(value) {
        const newValue = this.valueScaling !== undefined && value != null ? this.toFloat(value, this.valueScaling) : value;
        if (newValue !== this.numberValue) {
            this.applyFixedFractionFormat(newValue);
        }
    }
    dispatchEvent(eventName) {
        this.el.dispatchEvent(new CustomEvent(eventName, { detail: this.getValue() }));
    }
    init(options) {
        this.options = {
            ...DEFAULT_OPTIONS,
            ...options
        };
        if (this.options.autoDecimalDigits) {
            this.options.hideNegligibleDecimalDigitsOnFocus = false;
            this.el.setAttribute('inputmode', 'numeric');
        }
        else {
            this.el.setAttribute('inputmode', 'decimal');
        }
        this.currencyFormat = new CurrencyFormat(this.options);
        this.numberMask = this.options.autoDecimalDigits ? new AutoDecimalDigitsInputMask(this.currencyFormat) : new DefaultInputMask(this.currencyFormat);
        const valueScalingOptions = {
            [ValueScaling.precision]: this.currencyFormat.maximumFractionDigits,
            [ValueScaling.thousands]: 3,
            [ValueScaling.millions]: 6,
            [ValueScaling.billions]: 9
        };
        if (this.options.exportValueAsInteger) {
            this.valueScaling = valueScalingOptions[ValueScaling.precision];
        }
        else {
            this.valueScaling = this.options.valueScaling ? valueScalingOptions[this.options.valueScaling] : undefined;
        }
        this.valueScalingFractionDigits =
            this.valueScaling !== undefined && this.options.valueScaling !== ValueScaling.precision
                ? this.valueScaling + this.currencyFormat.maximumFractionDigits
                : this.currencyFormat.maximumFractionDigits;
        this.minValue = this.getMinValue();
        this.maxValue = this.getMaxValue();
    }
    getMinValue() {
        var _a, _b;
        let min = this.toFloat(-Number.MAX_SAFE_INTEGER);
        if (((_a = this.options.valueRange) === null || _a === void 0 ? void 0 : _a.min) !== undefined) {
            min = Math.max((_b = this.options.valueRange) === null || _b === void 0 ? void 0 : _b.min, this.toFloat(-Number.MAX_SAFE_INTEGER));
        }
        if (!this.options.autoSign && min < 0) {
            min = 0;
        }
        return min;
    }
    getMaxValue() {
        var _a, _b;
        let max = this.toFloat(Number.MAX_SAFE_INTEGER);
        if (((_a = this.options.valueRange) === null || _a === void 0 ? void 0 : _a.max) !== undefined) {
            max = Math.min((_b = this.options.valueRange) === null || _b === void 0 ? void 0 : _b.max, this.toFloat(Number.MAX_SAFE_INTEGER));
        }
        if (!this.options.autoSign && max < 0) {
            max = this.toFloat(Number.MAX_SAFE_INTEGER);
        }
        return max;
    }
    toFloat(value, maxFractionDigits) {
        return value / Math.pow(10, maxFractionDigits !== null && maxFractionDigits !== void 0 ? maxFractionDigits : this.valueScalingFractionDigits);
    }
    toInteger(value, maxFractionDigits) {
        return Number(value
            .toFixed(maxFractionDigits !== null && maxFractionDigits !== void 0 ? maxFractionDigits : this.valueScalingFractionDigits)
            .split('.')
            .join(''));
    }
    validateValueRange(value) {
        return value != null ? Math.min(Math.max(value, this.minValue), this.maxValue) : value;
    }
    applyFixedFractionFormat(number, forcedChange = false) {
        this.format(this.currencyFormat.format(this.validateValueRange(number)));
        if (number !== this.numberValue || forcedChange) {
            this.dispatchEvent('change');
        }
    }
    format(value, hideNegligibleDecimalDigits = false) {
        if (value != null) {
            if (this.decimalSymbolInsertedAt !== undefined) {
                value = this.currencyFormat.normalizeDecimalSeparator(value, this.decimalSymbolInsertedAt);
                this.decimalSymbolInsertedAt = undefined;
            }
            const conformedValue = this.numberMask.conformToMask(value, this.formattedValue);
            let formattedValue;
            if (typeof conformedValue === 'object') {
                const { numberValue, fractionDigits } = conformedValue;
                let { maximumFractionDigits, minimumFractionDigits } = this.currencyFormat;
                if (this.focus) {
                    minimumFractionDigits = hideNegligibleDecimalDigits
                        ? fractionDigits.replace(/0+$/, '').length
                        : Math.min(maximumFractionDigits, fractionDigits.length);
                }
                else if (Number.isInteger(numberValue) && !this.options.autoDecimalDigits && (this.options.precision === undefined || minimumFractionDigits === 0)) {
                    minimumFractionDigits = maximumFractionDigits = 0;
                }
                formattedValue =
                    this.toInteger(Math.abs(numberValue)) > Number.MAX_SAFE_INTEGER
                        ? this.formattedValue
                        : this.currencyFormat.format(numberValue, {
                            useGrouping: this.options.useGrouping && !(this.focus && this.options.hideGroupingSeparatorOnFocus),
                            minimumFractionDigits,
                            maximumFractionDigits
                        });
            }
            else {
                formattedValue = conformedValue;
            }
            if (this.options.autoSign) {
                if (this.maxValue <= 0 && !this.currencyFormat.isNegative(formattedValue) && this.currencyFormat.parse(formattedValue) !== 0) {
                    formattedValue = formattedValue.replace(this.currencyFormat.prefix, this.currencyFormat.negativePrefix);
                }
                if (this.minValue >= 0) {
                    formattedValue = formattedValue.replace(this.currencyFormat.negativePrefix, this.currencyFormat.prefix);
                }
            }
            if (this.options.currencyDisplay === CurrencyDisplay.hidden || (this.focus && this.options.hideCurrencySymbolOnFocus)) {
                formattedValue = formattedValue
                    .replace(this.currencyFormat.negativePrefix, this.currencyFormat.minusSymbol)
                    .replace(this.currencyFormat.prefix, '')
                    .replace(this.currencyFormat.suffix, '');
            }
            this.el.value = formattedValue;
            this.numberValue = this.currencyFormat.parse(formattedValue);
        }
        else {
            this.el.value = '';
            this.numberValue = null;
        }
        this.formattedValue = this.el.value;
        this.dispatchEvent('input');
    }
    addEventListener() {
        this.el.addEventListener('input', (e) => {
            if (!e.detail) {
                const { value, selectionStart } = this.el;
                const inputEvent = e;
                if (selectionStart && inputEvent.data && DECIMAL_SEPARATORS.includes(inputEvent.data)) {
                    this.decimalSymbolInsertedAt = selectionStart - 1;
                }
                this.format(value);
                if (this.focus && selectionStart != null) {
                    const getCaretPositionAfterFormat = () => {
                        const { prefix, suffix, decimalSymbol, maximumFractionDigits, groupingSymbol } = this.currencyFormat;
                        let caretPositionFromLeft = value.length - selectionStart;
                        const newValueLength = this.formattedValue.length;
                        if (this.formattedValue.substr(selectionStart, 1) === groupingSymbol &&
                            count(this.formattedValue, groupingSymbol) === count(value, groupingSymbol) + 1) {
                            return newValueLength - caretPositionFromLeft - 1;
                        }
                        if (newValueLength < caretPositionFromLeft) {
                            return selectionStart;
                        }
                        if (decimalSymbol !== undefined && value.indexOf(decimalSymbol) !== -1) {
                            const decimalSymbolPosition = value.indexOf(decimalSymbol) + 1;
                            if (Math.abs(newValueLength - value.length) > 1 && selectionStart <= decimalSymbolPosition) {
                                return this.formattedValue.indexOf(decimalSymbol) + 1;
                            }
                            else {
                                if (!this.options.autoDecimalDigits && selectionStart > decimalSymbolPosition) {
                                    if (this.currencyFormat.onlyDigits(value.substr(decimalSymbolPosition)).length - 1 === maximumFractionDigits) {
                                        caretPositionFromLeft -= 1;
                                    }
                                }
                            }
                        }
                        return this.options.hideCurrencySymbolOnFocus || this.options.currencyDisplay === CurrencyDisplay.hidden
                            ? newValueLength - caretPositionFromLeft
                            : Math.max(newValueLength - Math.max(caretPositionFromLeft, suffix.length), prefix.length);
                    };
                    this.setCaretPosition(getCaretPositionAfterFormat());
                }
            }
        }, { capture: true });
        this.el.addEventListener('focus', () => {
            this.focus = true;
            setTimeout(() => {
                const { value, selectionStart, selectionEnd } = this.el;
                this.format(value, this.options.hideNegligibleDecimalDigitsOnFocus);
                if (selectionStart != null && selectionEnd != null && Math.abs(selectionStart - selectionEnd) > 0) {
                    this.setCaretPosition(0, this.el.value.length);
                }
                else if (selectionStart != null) {
                    const getCaretPositionOnFocus = () => {
                        const { prefix, suffix, groupingSymbol } = this.currencyFormat;
                        if (!this.options.hideCurrencySymbolOnFocus && this.options.currencyDisplay !== CurrencyDisplay.hidden) {
                            if (selectionStart >= value.length - suffix.length) {
                                return this.formattedValue.length - suffix.length;
                            }
                            else if (selectionStart < prefix.length) {
                                return prefix.length;
                            }
                        }
                        let result = selectionStart;
                        if (this.options.hideCurrencySymbolOnFocus && this.options.currencyDisplay !== CurrencyDisplay.hidden) {
                            result -= prefix.length;
                        }
                        if (this.options.hideGroupingSeparatorOnFocus && groupingSymbol !== undefined) {
                            result -= count(value.substring(0, selectionStart), groupingSymbol);
                        }
                        return result;
                    };
                    this.setCaretPosition(getCaretPositionOnFocus());
                }
            });
        });
        this.el.addEventListener('blur', () => {
            this.focus = false;
            this.applyFixedFractionFormat(this.numberValue);
        });
        this.el.addEventListener('change', (e) => {
            if (!e.detail) {
                this.dispatchEvent('change');
            }
        }, { capture: true });
    }
    setCaretPosition(start, end = start) {
        this.el.setSelectionRange(start, end);
    }
}

const findInput = (el) => ((el === null || el === void 0 ? void 0 : el.matches('input')) ? el : el === null || el === void 0 ? void 0 : el.querySelector('input'));
var useCurrencyInput = (options) => {
    var _a;
    let numberInput;
    let input;
    const inputRef = ref(null);
    const formattedValue = ref(null);
    const instance = getCurrentInstance();
    const emit = (event, value) => instance === null || instance === void 0 ? void 0 : instance.emit(event, value);
    const lazyModel = isVue3 && ((_a = instance === null || instance === void 0 ? void 0 : instance.attrs.modelModifiers) === null || _a === void 0 ? void 0 : _a.lazy);
    const numberValue = computed(() => instance === null || instance === void 0 ? void 0 : instance.props[isVue3 ? 'modelValue' : 'value']);
    const inputEvent = isVue3 ? 'update:modelValue' : 'input';
    const changeEvent = lazyModel ? 'update:modelValue' : 'change';
    const hasInputEventListener = !isVue3 || !lazyModel;
    const hasChangeEventListener = !isVue3 || lazyModel || !(instance === null || instance === void 0 ? void 0 : instance.attrs.onChange);
    const onInput = (e) => {
        if (e.detail) {
            if (numberValue.value !== e.detail.number) {
                emit(inputEvent, e.detail.number);
            }
            formattedValue.value = e.detail.formatted;
        }
    };
    const onChange = (e) => {
        if (e.detail) {
            emit(changeEvent, e.detail.number);
            formattedValue.value = e.detail.formatted;
        }
    };
    watch(inputRef, (value) => {
        var _a, _b;
        if (value) {
            input = findInput((_b = (_a = value) === null || _a === void 0 ? void 0 : _a.$el) !== null && _b !== void 0 ? _b : value);
            if (input) {
                numberInput = new CurrencyInput(input, options);
                if (hasInputEventListener) {
                    input.addEventListener('input', onInput);
                }
                if (hasChangeEventListener) {
                    input.addEventListener('change', onChange);
                }
                numberInput.setValue(numberValue.value);
            }
            else {
                console.error('No input element found. Please make sure that the "inputRef" template ref is properly assigned.');
            }
        }
        else {
            numberInput = null;
        }
    });
    onUnmounted(() => {
        if (hasInputEventListener) {
            input === null || input === void 0 ? void 0 : input.removeEventListener('input', onInput);
        }
        if (hasChangeEventListener) {
            input === null || input === void 0 ? void 0 : input.removeEventListener('change', onChange);
        }
    });
    return {
        inputRef,
        formattedValue,
        setValue: (value) => numberInput === null || numberInput === void 0 ? void 0 : numberInput.setValue(value),
        setOptions: (options) => numberInput === null || numberInput === void 0 ? void 0 : numberInput.setOptions(options)
    };
};

const parse = (formattedValue, options) => {
    return new CurrencyFormat(options).parse(formattedValue);
};

export { CurrencyDisplay, ValueScaling, useCurrencyInput as default, parse, useCurrencyInput };
